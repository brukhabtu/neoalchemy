"""Working integration tests that verify real component cooperation.

Tests actual component integration by using real methods and verifying
real interactions between Repository, Transaction, QueryBuilder, and Models.
"""
import pytest
from unittest.mock import patch, MagicMock, call
from pydantic import ValidationError
from neoalchemy.orm.repository import Neo4jRepository
from neoalchemy.orm.query import QueryBuilder
from .conftest import PersonModel


@pytest.mark.integration
class TestWorkingIntegration:
    """Test actual working integration between components."""

    def test_querybuilder_find_actually_calls_repository_process_methods(self, mock_driver):
        """Test QueryBuilder.find() actually calls Repository._process_multiple_nodes()."""
        repo = Neo4jRepository(driver=mock_driver)
        
        # Mock Neo4j infrastructure
        mock_session = MagicMock()
        mock_tx = MagicMock()
        mock_session.begin_transaction.return_value = mock_tx
        mock_driver.session.return_value = mock_session
        
        # Mock query result
        mock_result = MagicMock()
        mock_tx.run.return_value = mock_result
        
        with repo.transaction() as tx:
            query_builder = tx.query(PersonModel)
            
            # Patch Repository method to verify QueryBuilder calls it
            with patch.object(repo, '_process_multiple_nodes') as mock_process:
                mock_process.return_value = [{"name": "Alice", "age": 30}]
                
                # QueryBuilder.find() should call Repository._process_multiple_nodes()
                results = query_builder.find()
                
                # Verify integration: QueryBuilder called Repository method
                mock_process.assert_called_once_with(mock_result)
                
                # Verify QueryBuilder used Repository result to create models
                assert len(results) == 1
                assert isinstance(results[0], PersonModel)
                assert results[0].name == "Alice"
                assert results[0].age == 30

    def test_querybuilder_find_one_actually_calls_repository_process_single_node(self, mock_driver):
        """Test QueryBuilder.find_one() actually calls Repository._process_single_node()."""
        repo = Neo4jRepository(driver=mock_driver)
        
        mock_session = MagicMock()
        mock_tx = MagicMock()
        mock_session.begin_transaction.return_value = mock_tx
        mock_driver.session.return_value = mock_session
        
        mock_result = MagicMock()
        mock_tx.run.return_value = mock_result
        
        with repo.transaction() as tx:
            query_builder = tx.query(PersonModel)
            
            # Patch Repository method to verify QueryBuilder calls it
            with patch.object(repo, '_process_single_node') as mock_process:
                mock_process.return_value = {"name": "Bob", "age": 25}
                
                # QueryBuilder.find_one() should call Repository._process_single_node()
                result = query_builder.find_one()
                
                # Verify integration: QueryBuilder called Repository method
                mock_process.assert_called_once_with(mock_result)
                
                # Verify QueryBuilder used Repository result
                assert isinstance(result, PersonModel)
                assert result.name == "Bob"
                assert result.age == 25

    def test_querybuilder_build_query_actually_generates_cypher_with_parameters(self, mock_driver):
        """Test QueryBuilder._build_query() actually generates valid Cypher."""
        repo = Neo4jRepository(driver=mock_driver)
        
        with repo.transaction() as tx:
            query_builder = tx.query(PersonModel).where(name="Charlie").limit(5)
            
            # Call real _build_query method
            cypher_query = query_builder._build_query()
            
            # Verify real query object was created
            assert cypher_query is not None
            assert hasattr(cypher_query, 'to_cypher')
            
            # Convert to actual Cypher string
            parameters = {}
            cypher_string, _ = cypher_query.to_cypher(parameters)
            
            # Verify real Cypher generation
            assert isinstance(cypher_string, str)
            assert "MATCH" in cypher_string
            assert "Person" in cypher_string
            assert "RETURN" in cypher_string

    def test_repository_transaction_actually_executes_querybuilder_cypher(self, mock_driver):
        """Test Repository transaction actually executes Cypher generated by QueryBuilder."""
        repo = Neo4jRepository(driver=mock_driver)
        
        mock_session = MagicMock()
        mock_tx = MagicMock()
        mock_session.begin_transaction.return_value = mock_tx
        mock_driver.session.return_value = mock_session
        
        # Mock successful query result
        mock_result = MagicMock()
        mock_tx.run.return_value = mock_result
        
        with repo.transaction() as tx:
            query_builder = tx.query(PersonModel).limit(3)
            
            # Patch Repository to capture what gets executed
            with patch.object(repo, '_process_multiple_nodes') as mock_process:
                mock_process.return_value = []
                
                # Execute query - should trigger Repository -> Neo4j execution
                query_builder.find()
                
                # Verify Repository transaction actually executed Neo4j query
                mock_tx.run.assert_called_once()
                
                # Verify QueryBuilder-generated Cypher was executed
                call_args = mock_tx.run.call_args
                executed_cypher = call_args[0][0]
                
                assert isinstance(executed_cypher, str)
                assert "MATCH" in executed_cypher
                assert "Person" in executed_cypher

    def test_model_validation_actually_prevents_repository_create_before_execution(self, mock_driver):
        """Test Model validation actually blocks Repository.create before any Neo4j calls."""
        repo = Neo4jRepository(driver=mock_driver)
        
        mock_session = MagicMock()
        mock_tx = MagicMock()
        mock_session.begin_transaction.return_value = mock_tx
        mock_driver.session.return_value = mock_session
        
        with repo.transaction() as tx:
            # Model validation should fail before Repository is called
            with pytest.raises(ValidationError):
                invalid_person = PersonModel(name=123, age="invalid")
            
            # Repository should never be called due to validation failure
            mock_tx.run.assert_not_called()
            
            # Valid model should allow Repository operation
            valid_person = PersonModel(name="Diana", age=28)
            
            # Mock successful create response
            mock_result = MagicMock()
            mock_record = MagicMock()
            mock_record.__getitem__.return_value = {"name": "Diana", "age": 28}
            mock_result.single.return_value = mock_record
            mock_tx.run.return_value = mock_result
            
            # This should succeed and call Repository
            created_person = tx.create(valid_person)
            
            # Verify Repository was actually called for valid model
            mock_tx.run.assert_called_once()
            assert created_person.name == "Diana"

    def test_querybuilder_where_conditions_actually_flow_to_repository_execution(self, mock_driver):
        """Test QueryBuilder where conditions actually affect Repository query execution."""
        repo = Neo4jRepository(driver=mock_driver)
        
        mock_session = MagicMock()
        mock_tx = MagicMock()
        mock_session.begin_transaction.return_value = mock_tx
        mock_driver.session.return_value = mock_session
        
        mock_result = MagicMock()
        mock_tx.run.return_value = mock_result
        
        with repo.transaction() as tx:
            # Create QueryBuilder with WHERE condition
            query_builder = tx.query(PersonModel).where(name="Eve")
            
            # Verify condition was added to QueryBuilder
            assert len(query_builder.conditions) > 0
            
            with patch.object(repo, '_process_multiple_nodes') as mock_process:
                mock_process.return_value = []
                
                # Execute query - conditions should flow to Repository
                query_builder.find()
                
                # Verify Repository received query with WHERE clause
                mock_tx.run.assert_called_once()
                call_args = mock_tx.run.call_args
                executed_cypher = call_args[0][0]
                
                # QueryBuilder conditions should appear in executed query
                assert "WHERE" in executed_cypher

    def test_querybuilder_limit_actually_affects_repository_query_execution(self, mock_driver):
        """Test QueryBuilder limit actually appears in Repository-executed query."""
        repo = Neo4jRepository(driver=mock_driver)
        
        mock_session = MagicMock()
        mock_tx = MagicMock()
        mock_session.begin_transaction.return_value = mock_tx
        mock_driver.session.return_value = mock_session
        
        mock_result = MagicMock()
        mock_tx.run.return_value = mock_result
        
        with repo.transaction() as tx:
            # Create QueryBuilder with limit
            query_builder = tx.query(PersonModel).limit(7)
            
            # Verify limit was set in QueryBuilder
            assert query_builder.limit_value == 7
            
            with patch.object(repo, '_process_multiple_nodes') as mock_process:
                mock_process.return_value = []
                
                # Execute query - limit should flow to Repository
                query_builder.find()
                
                # Verify Repository executed query with LIMIT
                mock_tx.run.assert_called_once()
                call_args = mock_tx.run.call_args
                executed_cypher = call_args[0][0]
                
                # QueryBuilder limit should appear in executed query
                assert "LIMIT" in executed_cypher

    def test_querybuilder_order_by_actually_affects_repository_query_execution(self, mock_driver):
        """Test QueryBuilder order_by actually appears in Repository-executed query."""
        repo = Neo4jRepository(driver=mock_driver)
        
        mock_session = MagicMock()
        mock_tx = MagicMock()
        mock_session.begin_transaction.return_value = mock_tx
        mock_driver.session.return_value = mock_session
        
        mock_result = MagicMock()
        mock_tx.run.return_value = mock_result
        
        with repo.transaction() as tx:
            # Create QueryBuilder with order by
            query_builder = tx.query(PersonModel).order_by("name")
            
            # Verify order by was set in QueryBuilder
            assert query_builder.order_by_field == "name"
            
            with patch.object(repo, '_process_multiple_nodes') as mock_process:
                mock_process.return_value = []
                
                # Execute query - order by should flow to Repository
                query_builder.find()
                
                # Verify Repository executed query with ORDER BY
                mock_tx.run.assert_called_once()
                call_args = mock_tx.run.call_args
                executed_cypher = call_args[0][0]
                
                # QueryBuilder order by should appear in executed query
                assert "ORDER BY" in executed_cypher

    def test_repository_model_serialization_actually_flows_to_neo4j_execution(self, mock_driver):
        """Test Repository._model_to_dict actually flows to Neo4j query execution."""
        repo = Neo4jRepository(driver=mock_driver)
        
        mock_session = MagicMock()
        mock_tx = MagicMock()
        mock_session.begin_transaction.return_value = mock_tx
        mock_driver.session.return_value = mock_session
        
        with repo.transaction() as tx:
            person = PersonModel(name="Frank", age=35)
            
            # Mock successful create response
            mock_result = MagicMock()
            mock_record = MagicMock()
            mock_record.__getitem__.return_value = {"name": "Frank", "age": 35}
            mock_result.single.return_value = mock_record
            mock_tx.run.return_value = mock_result
            
            # Patch serialization to verify Repository uses it
            with patch.object(repo, '_model_to_dict', wraps=repo._model_to_dict) as mock_serialize:
                tx.create(person)
                
                # Verify Repository serialized model
                mock_serialize.assert_called_once_with(person)
                
                # Verify serialized data flowed to Neo4j execution
                mock_tx.run.assert_called_once()
                call_args = mock_tx.run.call_args
                executed_query = call_args[0][0]
                executed_params = call_args[1] if len(call_args) > 1 else {}
                
                # Model data should flow through to execution
                assert "CREATE" in executed_query
                # Parameters should contain model data
                if executed_params:
                    assert any("Frank" in str(v) or "35" in str(v) for v in executed_params.values())

    def test_transaction_rollback_actually_affects_repository_operations(self, mock_driver):
        """Test transaction rollback actually calls Repository transaction rollback."""
        repo = Neo4jRepository(driver=mock_driver)
        
        mock_session = MagicMock()
        mock_tx = MagicMock()
        mock_session.begin_transaction.return_value = mock_tx
        mock_driver.session.return_value = mock_session
        
        # Simulate transaction that needs rollback
        try:
            with repo.transaction() as tx:
                person = PersonModel(name="Grace", age=30)
                
                # Mock successful operation first
                mock_result = MagicMock()
                mock_record = MagicMock()
                mock_record.__getitem__.return_value = {"name": "Grace", "age": 30}
                mock_result.single.return_value = mock_record
                mock_tx.run.return_value = mock_result
                
                tx.create(person)
                
                # Cause error to trigger rollback
                raise Exception("Simulated error")
                
        except Exception:
            pass
        
        # Verify Repository transaction actually called rollback
        mock_tx.rollback.assert_called_once()
        mock_tx.commit.assert_not_called()